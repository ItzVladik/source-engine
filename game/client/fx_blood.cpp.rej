--- game/client/fx_blood.cpp	2024-08-11 15:07:30.282935743 +0500
+++ game/client/fx_blood.cpp	2018-12-21 00:18:59.794327400 +0500
@@ -22,6 +22,8 @@
 #include "particle_simple3d.h"
 #include "particle_parse.h"
 
+#include "coolmod/smod_cvars.h"
+
 // memdbgon must be the last include file in a .cpp file!!!
 #include "tier0/memdbgon.h"
 
@@ -29,7 +31,8 @@
 CLIENTEFFECT_MATERIAL( "effects/blood_core" )
 CLIENTEFFECT_MATERIAL( "effects/blood_gore" )
 CLIENTEFFECT_MATERIAL( "effects/blood_drop" )
-CLIENTEFFECT_MATERIAL( "effects/blood_puff" )
+CLIENTEFFECT_MATERIAL("effects/blood_puff")
+CLIENTEFFECT_MATERIAL("particle/particle_noisesphere")
 CLIENTEFFECT_REGISTER_END()
 
 // Cached material handles
@@ -73,19 +76,29 @@
 //			b - 
 //			flags - 
 //-----------------------------------------------------------------------------
-void FX_BloodSpray( const Vector &origin, const Vector &normal, float scale, unsigned char r, unsigned char g, unsigned char b, int flags )
+//-----------------------------------------------------------------------------
+// Purpose: 
+// Input  : &origin - 
+//			&normal - 
+//			scale - 
+//			r - 
+//			g - 
+//			b - 
+//			flags - 
+//-----------------------------------------------------------------------------
+void FX_BloodSpray(const Vector &origin, const Vector &normal, float scale, unsigned char r, unsigned char g, unsigned char b, int flags)
 {
-	if ( UTIL_IsLowViolence() )
+	if (UTIL_IsLowViolence())
 		return;
 
 	//debugoverlay->AddLineOverlay( origin, origin + normal * 72, 255, 255, 255, true, 10 ); 
 
 	Vector offset;
-	float spread	= 0.2f;
-	
+	float spread = 0.2f;
+
 	//Find area ambient light color and use it to tint smoke
-	Vector worldLight = WorldGetLightForPoint( origin, true );
-	Vector color = Vector( (float)(worldLight[0] * r) / 255.0f, (float)(worldLight[1] * g) / 255.0f, (float)(worldLight[2] * b) / 255.0f );
+	Vector worldLight = Vector(1,1,1);
+	Vector color = Vector((float)(worldLight[0] * r) / 255.0f, (float)(worldLight[1] * g) / 255.0f, (float)(worldLight[2] * b) / 255.0f);
 	float colorRamp;
 
 	int i;
@@ -95,15 +108,15 @@
 	Vector right;
 	Vector up;
 
-	if (normal != Vector(0, 0, 1) )
+	if (normal != Vector(0, 0, 1))
 	{
-		right = normal.Cross( Vector(0, 0, 1) );
-		up = right.Cross( normal );
+		right = normal.Cross(Vector(0, 0, 1));
+		up = right.Cross(normal);
 	}
 	else
 	{
 		right = Vector(0, 0, 1);
-		up = right.Cross( normal );
+		up = right.Cross(normal);
 	}
 
 	//
@@ -113,89 +126,90 @@
 	{
 		TrailParticle *tParticle;
 
-		CSmartPtr<CTrailParticles> pTrailEmitter = CTrailParticles::Create( "blooddrops" );
-		if ( !pTrailEmitter )
+		CSmartPtr<CTrailParticles> pTrailEmitter = CTrailParticles::Create("blooddrops");
+		if (!pTrailEmitter)
 			return;
 
-		pTrailEmitter->SetSortOrigin( origin );
+		pTrailEmitter->SetSortOrigin(origin);
 
 		// Partial gravity on blood drops.
-		pTrailEmitter->SetGravity( 600.0 ); 
+		pTrailEmitter->SetGravity(600.0);
 
-		pTrailEmitter->GetBinding().SetBBox( origin - Vector( 32, 32, 32 ), origin + Vector( 32, 32, 32 ) );
-		pTrailEmitter->SetFlag( bitsPARTICLE_TRAIL_VELOCITY_DAMPEN );
-		pTrailEmitter->SetVelocityDampen( 0.2f );
+		pTrailEmitter->GetBinding().SetBBox(origin - Vector(32, 32, 32), origin + Vector(32, 32, 32));
+		pTrailEmitter->SetFlag(bitsPARTICLE_TRAIL_VELOCITY_DAMPEN);
+		pTrailEmitter->SetVelocityDampen(0.2f);
 
-		PMaterialHandle	hMaterial = ParticleMgr()->GetPMaterial( "effects/blood_drop" );
+		PMaterialHandle	hMaterial = ParticleMgr()->GetPMaterial("effects/blood_drop");
 
 		//
 		// Long stringy drops of blood.
 		//
-		for ( i = 0; i < 14; i++ )
+		for (i = 0; i < 14; i++)
 		{
 			// Originate from within a circle 'scale' inches in diameter.
 			offset = origin;
-			offset += right * random->RandomFloat( -0.5f, 0.5f ) * scale;
-			offset += up * random->RandomFloat( -0.5f, 0.5f ) * scale;
+			offset += right * random->RandomFloat(-0.5f, 0.5f) * scale;
+			offset += up * random->RandomFloat(-0.5f, 0.5f) * scale;
 
-			tParticle = (TrailParticle *) pTrailEmitter->AddParticle( sizeof(TrailParticle), hMaterial, offset );
+			tParticle = (TrailParticle *)pTrailEmitter->AddParticle(sizeof(TrailParticle), hMaterial, offset);
 
-			if ( tParticle == NULL )
+			if (tParticle == NULL)
 				break;
 
-			tParticle->m_flLifetime	= 0.0f;
+			tParticle->m_flLifetime = 0.0f;
 
-			offDir = normal + RandomVector( -0.3f, 0.3f );
+			offDir = normal + RandomVector(-0.3f, 0.3f);
+			offDir[2] += random->RandomFloat(0.0f, 2.0f);
 
-			tParticle->m_vecVelocity = offDir * random->RandomFloat( 4.0f * scale, 40.0f * scale );
-			tParticle->m_vecVelocity[2] += random->RandomFloat( 4.0f, 16.0f ) * scale;
+			tParticle->m_vecVelocity = offDir * random->RandomFloat(4.0f * scale, 40.0f * scale);
+			tParticle->m_vecVelocity[2] += random->RandomFloat(4.0f, 16.0f) * scale;
 
-			tParticle->m_flWidth		= random->RandomFloat( 0.125f, 0.275f ) * scale;
-			tParticle->m_flLength		= random->RandomFloat( 0.02f, 0.03f ) * scale;
-			tParticle->m_flDieTime		= random->RandomFloat( 0.5f, 1.0f );
+			tParticle->m_flWidth = random->RandomFloat(0.125f, 0.275f) * scale;
+			tParticle->m_flLength = random->RandomFloat(0.02f, 0.03f) * scale;
+			tParticle->m_flDieTime = random->RandomFloat(0.5f, 1.0f);
 
-			FloatToColor32( tParticle->m_color, color[0], color[1], color[2], 1.0f );
+			FloatToColor32(tParticle->m_color, color[0], color[1], color[2], 1.0f);
 		}
 
 		//
 		// Shorter droplets.
 		//
-		for ( i = 0; i < 24; i++ )
+		for (i = 0; i < 24; i++)
 		{
 			// Originate from within a circle 'scale' inches in diameter.
 			offset = origin;
-			offset += right * random->RandomFloat( -0.5f, 0.5f ) * scale;
-			offset += up * random->RandomFloat( -0.5f, 0.5f ) * scale;
+			offset += right * random->RandomFloat(-0.5f, 0.5f) * scale;
+			offset += up * random->RandomFloat(-0.5f, 0.5f) * scale;
 
-			tParticle = (TrailParticle *) pTrailEmitter->AddParticle( sizeof(TrailParticle), hMaterial, offset );
+			tParticle = (TrailParticle *)pTrailEmitter->AddParticle(sizeof(TrailParticle), hMaterial, offset);
 
-			if ( tParticle == NULL )
+			if (tParticle == NULL)
 				break;
 
-			tParticle->m_flLifetime	= 0.0f;
+			tParticle->m_flLifetime = 0.0f;
 
-			offDir = normal + RandomVector( -1.0f, 1.0f );
+			offDir = normal + RandomVector(-1.0f, 1.0f);
 			offDir[2] += random->RandomFloat(0, 1.0f);
 
-			tParticle->m_vecVelocity = offDir * random->RandomFloat( 2.0f * scale, 25.0f * scale );
-			tParticle->m_vecVelocity[2] += random->RandomFloat( 4.0f, 16.0f ) * scale;
+			tParticle->m_vecVelocity = offDir * random->RandomFloat(2.0f * scale, 25.0f * scale);
+			tParticle->m_vecVelocity[2] += random->RandomFloat(4.0f, 16.0f) * scale;
 
-			tParticle->m_flWidth		= random->RandomFloat( 0.25f, 0.375f ) * scale;
-			tParticle->m_flLength		= random->RandomFloat( 0.0025f, 0.005f ) * scale;
-			tParticle->m_flDieTime		= random->RandomFloat( 0.5f, 1.0f );
+			tParticle->m_flWidth = random->RandomFloat(0.25f, 0.375f) * scale;
+			tParticle->m_flLength = random->RandomFloat(0.0025f, 0.005f) * scale;
+			tParticle->m_flDieTime = random->RandomFloat(0.5f, 1.0f);
 
-			FloatToColor32( tParticle->m_color, color[0], color[1], color[2], 1.0f );
+			FloatToColor32(tParticle->m_color, color[0], color[1], color[2], 1.0f);
 		}
 	}
 
 	if ((flags & FX_BLOODSPRAY_GORE) || (flags & FX_BLOODSPRAY_CLOUD))
 	{
-		CSmartPtr<CBloodSprayEmitter> pSimple = CBloodSprayEmitter::Create( "bloodgore" );
-		if ( !pSimple )
+		CSmartPtr<CBloodSprayEmitter> pSimple = CBloodSprayEmitter::Create("bloodgore");
+		if (!pSimple)
 			return;
 
-		pSimple->SetSortOrigin( origin );
-		pSimple->SetGravity( 0 );
+		pSimple->SetSortOrigin(origin);
+		pSimple->SetGravity(0);
 
 		PMaterialHandle	hMaterial;
 
@@ -204,43 +218,43 @@
 		//
 		if (flags & FX_BLOODSPRAY_GORE)
 		{
-			hMaterial = ParticleMgr()->GetPMaterial( "effects/blood_gore" );
+			hMaterial = ParticleMgr()->GetPMaterial("effects/blood_gore");
 
 			SimpleParticle *pParticle;
 
-			for ( i = 0; i < 6; i++ )
+			for (i = 0; i < 6; i++)
 			{
 				// Originate from within a circle 'scale' inches in diameter.
-				offset = origin + ( 0.5 * scale * normal );
-				offset += right * random->RandomFloat( -0.5f, 0.5f ) * scale;
-				offset += up * random->RandomFloat( -0.5f, 0.5f ) * scale;
+				offset = origin + (0.5 * scale * normal);
+				//offset += right * random->RandomFloat(-0.5f, 0.5f) * scale;
+				//offset += up * random->RandomFloat(-0.5f, 0.5f) * scale;
 
-				pParticle = (SimpleParticle *) pSimple->AddParticle( sizeof( SimpleParticle ), hMaterial, offset );
+				pParticle = (SimpleParticle *)pSimple->AddParticle(sizeof(SimpleParticle), hMaterial, offset);
 
-				if ( pParticle != NULL )
+				if (pParticle != NULL)
 				{
 					pParticle->m_flLifetime = 0.0f;
-					pParticle->m_flDieTime	= 0.3f;
+					pParticle->m_flDieTime = 0.3f;
 
 					spread = 0.2f;
-					pParticle->m_vecVelocity.Random( -spread, spread );
-					pParticle->m_vecVelocity += normal * random->RandomInt( 10, 100 );
+					pParticle->m_vecVelocity.Random(-spread, spread);
+					pParticle->m_vecVelocity += normal * random->RandomInt(10, 100);
 					//VectorNormalize( pParticle->m_vecVelocity );
 
-					colorRamp = random->RandomFloat( 0.75f, 1.25f );
+					colorRamp = random->RandomFloat(0.75f, 1.25f);
+
+					pParticle->m_uchColor[0] = min(1.0f, color[0] * colorRamp) * 255.0f;
+					pParticle->m_uchColor[1] = min(1.0f, color[1] * colorRamp) * 255.0f;
+					pParticle->m_uchColor[2] = min(1.0f, color[2] * colorRamp) * 255.0f;
 
-					pParticle->m_uchColor[0]	= MIN( 1.0f, color[0] * colorRamp ) * 255.0f;
-					pParticle->m_uchColor[1]	= MIN( 1.0f, color[1] * colorRamp ) * 255.0f;
-					pParticle->m_uchColor[2]	= MIN( 1.0f, color[2] * colorRamp ) * 255.0f;
-					
-					pParticle->m_uchStartSize	= random->RandomFloat( scale * 0.25, scale );
-					pParticle->m_uchEndSize		= pParticle->m_uchStartSize * 2;
-					
-					pParticle->m_uchStartAlpha	= random->RandomInt( 200, 255 );
-					pParticle->m_uchEndAlpha	= 0;
-					
-					pParticle->m_flRoll			= random->RandomInt( 0, 360 );
-					pParticle->m_flRollDelta	= 0.0f;
+					pParticle->m_uchStartSize = random->RandomFloat(scale * 0.25, scale);
+					pParticle->m_uchEndSize = pParticle->m_uchStartSize * 2;
+
+					pParticle->m_uchStartAlpha = random->RandomInt(200, 255);
+					pParticle->m_uchEndAlpha = 0;
+
+					pParticle->m_flRoll = random->RandomInt(0, 360);
+					pParticle->m_flRollDelta = 0.0f;
 				}
 			}
 		}
@@ -250,42 +264,84 @@
 		//
 		if (flags & FX_BLOODSPRAY_CLOUD)
 		{
-			hMaterial = ParticleMgr()->GetPMaterial( "effects/blood_puff" );
+			hMaterial = ParticleMgr()->GetPMaterial("effects/blood_puff");
 
 			SimpleParticle *pParticle;
 
-			for ( i = 0; i < 6; i++ )
+			for (i = 0; i < 6; i++)
 			{
+				float amount = i;
+				amount = RemapValClamped(amount, 0, 6, 1, 2);
 				// Originate from within a circle '2 * scale' inches in diameter.
-				offset = origin + ( scale * normal );
-				offset += right * random->RandomFloat( -1, 1 ) * scale;
-				offset += up * random->RandomFloat( -1, 1 ) * scale;
+				offset = origin + (scale * normal * amount * 5);
+				//offset += right * random->RandomFloat(-1, 1) * scale;
+				//offset += up * random->RandomFloat(-1, 1) * scale;
 
-				pParticle = (SimpleParticle *) pSimple->AddParticle( sizeof( SimpleParticle ), hMaterial, offset );
+				pParticle = (SimpleParticle *)pSimple->AddParticle(sizeof(SimpleParticle), hMaterial, offset);
 
-				if ( pParticle != NULL )
+				if (pParticle != NULL)
 				{
 					pParticle->m_flLifetime = 0.0f;
-					pParticle->m_flDieTime	= random->RandomFloat( 0.5f, 0.8f);
+					pParticle->m_flDieTime = random->RandomFloat(0.5f, 0.8f) / 5;
 
 					spread = 0.5f;
-					pParticle->m_vecVelocity.Random( -spread, spread );
-					pParticle->m_vecVelocity += normal * random->RandomInt( 100, 200 );
+					//pParticle->m_vecVelocity.Random(-spread, spread);
+					//pParticle->m_vecVelocity += normal * random->RandomInt(100, 200);
+					pParticle->m_vecVelocity = vec3_origin;
+
+					colorRamp = random->RandomFloat(0.75f, 1.25f);
+
+					pParticle->m_uchColor[0] = min(1.0f, color[0] * colorRamp) * 255.0f;
+					pParticle->m_uchColor[1] = min(1.0f, color[1] * colorRamp) * 255.0f;
+					pParticle->m_uchColor[2] = min(1.0f, color[2] * colorRamp) * 255.0f;
 
-					colorRamp = random->RandomFloat( 0.75f, 1.25f );
+					pParticle->m_uchStartSize = random->RandomFloat(scale * 1.5f, scale * 2.0f) * amount;
+					pParticle->m_uchEndSize = pParticle->m_uchStartSize;
 
-					pParticle->m_uchColor[0]	= MIN( 1.0f, color[0] * colorRamp ) * 255.0f;
-					pParticle->m_uchColor[1]	= MIN( 1.0f, color[1] * colorRamp ) * 255.0f;
-					pParticle->m_uchColor[2]	= MIN( 1.0f, color[2] * colorRamp ) * 255.0f;
-					
-					pParticle->m_uchStartSize	= random->RandomFloat( scale * 1.5f, scale * 2.0f );
-					pParticle->m_uchEndSize		= pParticle->m_uchStartSize * 4;
-					
-					pParticle->m_uchStartAlpha	= random->RandomInt( 80, 128 );
-					pParticle->m_uchEndAlpha	= 0;
-					
-					pParticle->m_flRoll			= random->RandomInt( 0, 360 );
-					pParticle->m_flRollDelta	= 0.0f;
+					pParticle->m_uchStartAlpha = random->RandomInt(80, 128) * 2;
+					pParticle->m_uchEndAlpha = 0;
+
+					pParticle->m_flRoll = random->RandomInt(0, 360);
+					pParticle->m_flRollDelta = 0.0f;
+				}
+			}
+		}
+
+		//
+		// Blood core
+		//
+		{
+			hMaterial = ParticleMgr()->GetPMaterial("effects/blood_core");
+
+			SimpleParticle *pParticle;
+
+			//for (i = 0; i < 1; i++)
+			{
+				pParticle = (SimpleParticle *)pSimple->AddParticle(sizeof(SimpleParticle), hMaterial, origin);
+
+				if (pParticle != NULL)
+				{
+					pParticle->m_flLifetime = 0.0f;
+					pParticle->m_flDieTime = random->RandomFloat(0.1f, 0.25f);
+
+					spread = 0.5f;
+					//pParticle->m_vecVelocity.Random(-spread, spread);
+					pParticle->m_vecVelocity = vec3_origin;
+
+					colorRamp = random->RandomFloat(0.75f, 1.25f);
+
+					pParticle->m_uchColor[0] = min(1.0f, color[0] * colorRamp) * 255.0f;
+					pParticle->m_uchColor[1] = min(1.0f, color[1] * colorRamp) * 255.0f;
+					pParticle->m_uchColor[2] = min(1.0f, color[2] * colorRamp) * 255.0f;
+
+					pParticle->m_uchStartSize = random->RandomFloat(scale * 1.5f, scale * 2.0f) * 2.75f;
+					pParticle->m_uchEndSize = pParticle->m_uchStartSize;
+
+					pParticle->m_uchStartAlpha = random->RandomInt(128, 255);
+					pParticle->m_uchEndAlpha = 0;
+
+					pParticle->m_flRoll = random->RandomInt(0, 360);
+					pParticle->m_flRollDelta = 0.0f;
 				}
 			}
 		}
@@ -296,6 +352,299 @@
 	//C_BaseEntity::EmitSound( filter, SOUND_FROM_WORLD, CHAN_VOICE, "Physics.WaterSplash", 1.0, ATTN_NORM, 0, 100, &origin );
 }
 
+void FX_BloodTrail(const Vector &origin, const Vector &start, float scale, unsigned char r, unsigned char g, unsigned char b, int flags)
+{
+
+	if (UTIL_IsLowViolence())
+		return;
+
+	//debugoverlay->AddLineOverlay( origin, origin + normal * 72, 255, 255, 255, true, 10 ); 
+
+	Vector offset;
+
+	//Find area ambient light color and use it to tint smoke
+	Vector worldLight = Vector(1,1,1);
+	Vector color = Vector((float)(worldLight[0] * r) / 255.0f, (float)(worldLight[1] * g) / 255.0f, (float)(worldLight[2] * b) / 255.0f);
+
+	int i;
+
+	Vector	offDir;
+
+	//
+	// Dump out drops
+	//
+	if (flags & FX_BLOODSPRAY_DROPS)
+	{
+		TrailParticle *tParticle;
+
+		CSmartPtr<CTrailParticles> pTrailEmitter = CTrailParticles::Create("blooddrops");
+		if (!pTrailEmitter)
+			return;
+
+		pTrailEmitter->SetSortOrigin(origin);
+
+		// Partial gravity on blood drops.
+		pTrailEmitter->SetGravity(600.0);
+		pTrailEmitter->SetFlag(bitsPARTICLE_TRAIL_VELOCITY_DAMPEN);
+		pTrailEmitter->SetVelocityDampen(0.2f);
+
+		pTrailEmitter->GetBinding().SetBBox(origin - Vector(32, 32, 32), origin + Vector(32, 32, 32));
+
+		PMaterialHandle	hTrailMaterial = ParticleMgr()->GetPMaterial("effects/blood_splash");
+
+		//
+		// Long blood trails from SMOD.
+		//
+		Vector	dir;
+
+		for (i = 0; i < 4; i++)
+		{
+
+			tParticle = (TrailParticle *)pTrailEmitter->AddParticle(sizeof(TrailParticle), hTrailMaterial, origin);
+
+			if (tParticle == NULL)
+				return;
+
+			tParticle->m_flLifetime = 0.0f;
+			tParticle->m_flDieTime = random->RandomFloat(1.1f, 2.2f);
+
+			float	spreadOfs = random->RandomFloat(2.0f, 5.5f);
+			dir[0] = start[0] + random->RandomFloat(-(1*spreadOfs), (1*spreadOfs));
+			dir[1] = start[1] + random->RandomFloat(-(1*spreadOfs), (1*spreadOfs));
+			dir[2] = start[2] + random->RandomFloat(-(1*spreadOfs), (1*spreadOfs));
+			tParticle->m_vecVelocity = dir * spreadOfs * 0.25;
+
+			tParticle->m_flWidth = random->RandomFloat(0.125f, 0.275f) * 10 + random->RandomFloat(0.0f, 0.5f);
+			tParticle->m_flLength = random->RandomFloat(0.125f, 0.275f) * 5 * random->RandomFloat(0.02, 0.05f);
+			FloatToColor32(tParticle->m_color, color[0], color[1], color[2], 20.0f);
+		}
+	}
+
+	if ((flags & FX_BLOODSPRAY_GORE) || (flags & FX_BLOODSPRAY_CLOUD))
+	{
+		CSmartPtr<CBloodSprayEmitter> pSimple = CBloodSprayEmitter::Create("bloodgore");
+		if (!pSimple)
+			return;
+
+		pSimple->SetSortOrigin(origin);
+		pSimple->SetGravity(0);
+
+		PMaterialHandle	hMaterial;
+
+		//
+		// Diffuse cloud just in front of the exit wound.
+		//
+		if (flags & FX_BLOODSPRAY_CLOUD)
+		{
+			hMaterial = ParticleMgr()->GetPMaterial("particle/particle_noisesphere");
+
+			SimpleParticle *pParticle;
+
+			for (i = 0; i < 6; i++)
+			{
+				// Originate from within a circle '2 * scale' inches in diameter.
+				offset = origin;
+
+				pParticle = (SimpleParticle *)pSimple->AddParticle(sizeof(SimpleParticle), hMaterial, offset);
+
+				if (pParticle != NULL)
+				{
+					pParticle->m_flLifetime = 0.0f;
+					pParticle->m_flDieTime = random->RandomFloat(0.75f, 1.5f);
+
+					float spread = 0.5f;
+					pParticle->m_vecVelocity.Random(-spread, spread);
+					pParticle->m_vecVelocity += 0;
+
+					float colorRamp = random->RandomFloat(0.75f, 1.25f);
+
+					pParticle->m_uchColor[0] = MIN(1.0f, color[0] * colorRamp) * 255.0f;
+					pParticle->m_uchColor[1] = MIN(1.0f, color[1] * colorRamp) * 255.0f;
+					pParticle->m_uchColor[2] = MIN(1.0f, color[2] * colorRamp) * 255.0f;
+
+					pParticle->m_uchStartSize = random->RandomFloat(scale * 1.5f, scale * 2.0f);
+					pParticle->m_uchEndSize = pParticle->m_uchStartSize * 2;
+
+					pParticle->m_uchStartAlpha = random->RandomInt(40, 64);
+					pParticle->m_uchEndAlpha = 0;
+
+					pParticle->m_flRoll = random->RandomInt(0, 360);
+					pParticle->m_flRollDelta = 0.0f;
+				}
+			}
+		}
+	}
+
+	// TODO: Play a sound?
+	//CLocalPlayerFilter filter;
+	//C_BaseEntity::EmitSound( filter, SOUND_FROM_WORLD, CHAN_VOICE, "Physics.WaterSplash", 1.0, ATTN_NORM, 0, 100, &origin );
+}
+
+void FX_BigBloodTrail(const Vector &origin, const Vector &start, float scale, unsigned char r, unsigned char g, unsigned char b, int flags)
+{
+
+	if (UTIL_IsLowViolence())
+		return;
+
+	//debugoverlay->AddLineOverlay( origin, origin + normal * 72, 255, 255, 255, true, 10 ); 
+
+	Vector offset;
+
+	//Find area ambient light color and use it to tint smoke
+	Vector worldLight = WorldGetLightForPoint(origin, true);
+	Vector color = Vector((float)(worldLight[0] * r) / 255.0f, (float)(worldLight[1] * g) / 255.0f, (float)(worldLight[2] * b) / 255.0f);
+
+	int i;
+
+	//
+	// Dump out drops
+	//
+	if (flags & FX_BLOODSPRAY_DROPS)
+	{
+		TrailParticle *tParticle;
+
+		CSmartPtr<CTrailParticles> pTrailEmitter = CTrailParticles::Create("blooddrops");
+		if (!pTrailEmitter)
+			return;
+
+		pTrailEmitter->SetSortOrigin(origin);
+
+		// Partial gravity on blood drops.
+		pTrailEmitter->SetGravity(600.0);
+
+		pTrailEmitter->GetBinding().SetBBox(origin - Vector(32, 32, 32), origin + Vector(32, 32, 32));
+
+		PMaterialHandle	hTrailMaterial = ParticleMgr()->GetPMaterial("effects/blood_splash");
+
+		//
+		// Tiny blood trails from SMOD.
+		//
+
+		Vector offDir = (start)+(RandomVector(-10.9f, 10.9f));
+
+		for (i = 0; i < 2; i++)
+		{
+
+			tParticle = (TrailParticle *)pTrailEmitter->AddParticle(sizeof(TrailParticle), hTrailMaterial, origin);
+
+			if (tParticle == NULL)
+				break;
+
+			tParticle->m_flLifetime = 0.0f;
+
+			tParticle->m_vecVelocity = offDir;
+
+			tParticle->m_flWidth = random->RandomFloat(0.125f, 0.275f) * 10;
+			tParticle->m_flLength = random->RandomFloat(0.02f, 0.03f) * 2.5f;
+			tParticle->m_flDieTime = random->RandomFloat(0.5f, 1.0f) / 10;
+
+			FloatToColor32(tParticle->m_color, color[0], color[1], color[2], 20.0f);
+		}
+	}
+}
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+// Input  : &origin - 
+//			&normal - 
+//			scale - 
+//			r - 
+//			g - 
+//			b - 
+//			flags - 
+//-----------------------------------------------------------------------------
+void FX_BloodSplat(const Vector &origin, const Vector &normal, float scale, unsigned char r, unsigned char g, unsigned char b, int flags)
+{
+
+	if (UTIL_IsLowViolence())
+		return;
+
+	//debugoverlay->AddLineOverlay( origin, origin + normal * 72, 255, 255, 255, true, 10 ); 
+
+	Vector offset;
+	float spread = 0.2f;
+
+	//Find area ambient light color and use it to tint smoke
+	Vector worldLight = WorldGetLightForPoint(origin, true);
+	Vector color = Vector((float)(worldLight[0] * r) / 255.0f, (float)(worldLight[1] * g) / 255.0f, (float)(worldLight[2] * b) / 255.0f);
+	float colorRamp;
+
+	int i;
+
+	Vector	offDir;
+
+	Vector right;
+	Vector up;
+
+	if (normal != Vector(0, 0, 1))
+	{
+		right = normal.Cross(Vector(0, 0, 1));
+		up = right.Cross(normal);
+	}
+	else
+	{
+		right = Vector(0, 0, 1);
+		up = right.Cross(normal);
+	}
+
+	if ((flags & FX_BLOODSPRAY_GORE) || (flags & FX_BLOODSPRAY_CLOUD))
+	{
+		CSmartPtr<CBloodSprayEmitter> pSimple = CBloodSprayEmitter::Create("bloodgore");
+		if (!pSimple)
+			return;
+
+		pSimple->SetSortOrigin(origin);
+		pSimple->SetGravity(0);
+
+		PMaterialHandle	hMaterial;
+
+		//
+		// Diffuse cloud just in front of the exit wound.
+		//
+		if (flags & FX_BLOODSPRAY_CLOUD)
+		{
+			hMaterial = ParticleMgr()->GetPMaterial("particle/particle_noisesphere");
+
+			SimpleParticle *pParticle;
+
+			for (i = 0; i < 2; i++)
+			{
+				// Originate from within a circle '2 * scale' inches in diameter.
+				offset = origin + (scale * normal);
+				offset += right * random->RandomFloat(-1, 1) * scale;
+				offset += up * random->RandomFloat(-1, 1) * scale;
+
+				pParticle = (SimpleParticle *)pSimple->AddParticle(sizeof(SimpleParticle), hMaterial, offset);
+
+				if (pParticle != NULL)
+				{
+					pParticle->m_flLifetime = 0.0f;
+					pParticle->m_flDieTime = random->RandomFloat(0.5f, 0.8f) * 15;
+
+					spread = 0.5f;
+					pParticle->m_vecVelocity.Random(-spread, spread);
+					pParticle->m_vecVelocity += RandomVector(-5.0f, 5.0f);
+
+					colorRamp = random->RandomFloat(0.75f, 1.25f);
+
+					pParticle->m_uchColor[0] = MIN(1.0f, color[0] * colorRamp) * 255.0f;
+					pParticle->m_uchColor[1] = MIN(1.0f, color[1] * colorRamp) * 255.0f;
+					pParticle->m_uchColor[2] = MIN(1.0f, color[2] * colorRamp) * 255.0f;
+
+					pParticle->m_uchStartSize = random->RandomFloat(scale * 1.5f, scale * 2.0f);
+					pParticle->m_uchEndSize = pParticle->m_uchStartSize * 15;
+
+					pParticle->m_uchStartAlpha = random->RandomInt(80, 128) * 0.25f;
+					pParticle->m_uchEndAlpha = 0;
+
+					pParticle->m_flRoll = random->RandomInt(0, 360);
+					pParticle->m_flRollDelta = 0.0f;
+				}
+			}
+		}
+	}
+}
+
 //-----------------------------------------------------------------------------
 // Purpose: Used for bullets hitting bleeding surfaces
 // Input  : origin - 
@@ -503,20 +852,23 @@
 {
 	bool bFoundBlood = false;
 
-	// Find which sort of blood we are
-	for ( int i = 0; i < ARRAYSIZE( bloodCallbacks ); i++ )
+	if (gore_drawgoo.GetBool())
 	{
-		if ( bloodCallbacks[i].nColor == data.m_nColor )
+		// Find which sort of blood we are
+		for (int i = 0; i < ARRAYSIZE(bloodCallbacks); i++)
 		{
-			QAngle	vecAngles;
-			VectorAngles( -data.m_vNormal, vecAngles );
-			DispatchParticleEffect( bloodCallbacks[i].lpszParticleSystemName, data.m_vOrigin, vecAngles );
-			bFoundBlood = true;
-			break;
+			if (bloodCallbacks[i].nColor == data.m_nColor)
+			{
+				QAngle	vecAngles;
+				VectorAngles(-data.m_vNormal, vecAngles);
+
+				DispatchParticleEffect(bloodCallbacks[i].lpszParticleSystemName, data.m_vOrigin, vecAngles);
+				bFoundBlood = true;
+				break;
+			}
 		}
 	}
 
-	if ( bFoundBlood == false )
 	{
 		Vector vecPosition;
 		vecPosition = data.m_vOrigin;
@@ -525,12 +877,61 @@
 		colorentry_t color;
 		GetBloodColor( data.m_nColor, color );
 
-		FX_BloodBulletImpact( vecPosition, data.m_vNormal, data.m_flScale, color.r, color.g, color.b );
+		FX_BloodSpray( vecPosition, data.m_vNormal, data.m_flScale / 5, color.r, color.g, color.b, FX_BLOODSPRAY_ALL);
 	}
 }
 
 DECLARE_CLIENT_EFFECT( "BloodImpact", BloodImpactCallback );
 
+void BloodDripSplatCallback(const CEffectData &data)
+{
+	colorentry_t color;
+
+	GetBloodColor(data.m_nColor, color);
+	FX_BloodSplat(data.m_vOrigin, -data.m_vNormal, data.m_flScale, color.r, color.g, color.b, data.m_fFlags);
+}
+
+DECLARE_CLIENT_EFFECT("bloodsplat", BloodDripSplatCallback);
+
+void BloodDripTrailCallback(const CEffectData &data)
+{
+	colorentry_t color;
+
+	GetBloodColor(data.m_nColor, color);
+	FX_BloodTrail(data.m_vOrigin, data.m_vStart, data.m_flScale, color.r, color.g, color.b, data.m_fFlags);
+}
+
+DECLARE_CLIENT_EFFECT("bloodtrail", BloodDripTrailCallback);
+
+//-----------------------------------------------------------------------------
+// Purpose: 
+// Input  : &data - 
+//-----------------------------------------------------------------------------
+void BloodPuddleImpactCallback(const CEffectData &data)
+{
+	colorentry_t color;
+	GetBloodColor(data.m_nColor, color);
+	Vector vecColor = Vector((float)(color.r) / 255.0f, (float)(color.g) / 255.0f, (float)(color.b) / 255.0f);
+
+
+	FX_AddQuad(data.m_vOrigin,
+		data.m_vNormal,
+		random->RandomFloat(20, 30),
+		200,
+		0.75f,
+		0.25f,
+		0.0f,
+		0.1f,
+		random->RandomInt(0, 360),
+		0,
+		vecColor,
+		25.0f,
+		"particle/particle_noisesphere",
+		(FXQUAD_BIAS_SCALE | FXQUAD_BIAS_ALPHA));
+}
+
+DECLARE_CLIENT_EFFECT("BloodPuddle", BloodPuddleImpactCallback);
+
 //-----------------------------------------------------------------------------
 //-----------------------------------------------------------------------------
 void HunterDamageCallback( const CEffectData &data )
